#include	"uart.h"

volatile uint8 Flag=FALSE;


//接收缓冲区数据定义
uint8 Uart1_RX_Buffer[RX_MAX_LEN];	//接收缓冲区
uint8 Recv_Cnt = 0;									//接收字节个数，缓冲区索引
uint8 Recv_OK = 0;									//一帧接收完成标志
uint8 Unitaddr = 0x30;							//本机地址

uint8 Uart1_SEND_Buffer[SEND_MAX_LEN];		//发送缓冲区，在config.h中定义全局变量SEND_MAX_LEN


/***************************************************************************
 * 描  述 : 串口1初始化函数
 * 入  参 : 无
 * 返回值 : 无
备注：波特率9600bps   晶振11.0592MHz
 **************************************************************************/
void Uart1_Init(void)
{	
//	P_SW1|=0X40;     	//串口1切换 P36,P37				缺省
//	P_SW1&=0X7F; 			//串口1切换 P36,P37	
	
	S1_USE_P36P37();		//串口1切换 P36,P37	
	TXEN485 = 0;				//初始485口处于接收状态		缺省
	
	PCON &= 0x3f;				//波特率不倍速，串行口工作方式由SM0、SM1决定
	SCON = 0x50;				//8位数据,可变波特率，启动串行接收器
	
	//AUXR |= 0x04;     //定时器2时钟为Fosc,即1T
	Timer2_1T();				//定时器2时钟为Fosc,即1T
	//AUXR |= 0x05;     	//定时器2作为波特率发生器
	S1_BRT_UseTimer2();	//定时器2作为波特率发生器

	T2L = (65536 - (MAIN_Fosc/4/9600)); //设置波特率重装值,缺省9600
	T2H = (65536 - (MAIN_Fosc/4/9600))>>8;	
	
	if(BaudAddr[0] == 0x06)
	{
			T2L = (65536 - (MAIN_Fosc/4/19200)); //设置波特率重装值19200
			T2H = (65536 - (MAIN_Fosc/4/19200))>>8;	
	}

	
	//AUXR |= 0x10;     //启动定时器2
	Timer2_Run();     //启动定时器2
	
	//IE2 &= 0xfb;			//禁止定时器2中断
	Timer2_InterruptDisable();	//禁止定时器2中断
	ES = 1;         	// 允许串口总中断，打开
}


/***************************************************************************
 * 描  述 : 串口1发送数据函数
 * 入  参 : uint8 数据
 * 返回值 : 无
 **************************************************************************/
void SendDataByUart1(uint8 dat)
{
    SBUF = dat;                 //写数据到UART数据寄存器
		while(TI == 0);             //在停止位没有发送时，TI为0即一直等待
		TI = 0;                     //清除TI位（该位必须软件清零）
}

/***************************************************************************
 * 描  述 : 串口1发送字符串函数
 * 入  参 : uint8 *s 待发送字符串 
 * 返回值 : 无
 **************************************************************************/
void SendStringByUart1(uint8 *s)
{
	while(*s)
	{
		SendDataByUart1(*s++);       //将字符串中的字符一个一个发送
	}
}

/***************************************************************************
 * 描  述 : 重定向c库函数printf到USART1
 * 入  参 : char dat
 * 返回值 : char 
 **************************************************************************/
char putchar(char dat)
{
		SendDataByUart1(dat);           
		return dat;                    
}


/***************************************************************************
 * 描  述 : 串口1中断服务函数
 * 入  参 : 无
 * 返回值 : 无
 **************************************************************************/
void Uart1() interrupt UART1_VECTOR using 1
{
	ES = 0;  	                  // 串口1中断关闭
	if (RI)                     //串行接收到停止位的中间时刻时，该位置1
  {
      RI = 0;                 //清除RI位 （该位必须软件清零）
			
			//非本机地址数据不接收
			//广播地址0，从站地址，首个字符接收时
			if(Recv_Cnt == 0 || Uart1_RX_Buffer[0] == BaudAddr[1] || Uart1_RX_Buffer[0] == 0x00)	//从机地址,在EEPROM.C定义
			{
					Uart1_RX_Buffer[Recv_Cnt++] = SBUF;
					if(Recv_Cnt >= RX_MAX_LEN)
							Recv_Cnt = 0;
					
					TR0 = 0;     				//关闭定时器0定时器，否则无法重新设定TL0??				
					TL0 = (65536-T1TMS);       	//每次接收到数据，定时器重新装载定时值
					TH0 = (65536-T1TMS) >> 8; 	//每次接收到数据，定时器重新装载定时值
					TR0 = 1;     	 			//打开定时器0，开始运行 					
   	 			//打开定时器2，开始运行 
			}  
   }
   if (TI)                    //在停止位开始发送时，该位置1
   {
      TI = 0;                 //清除TI位（该位必须软件清零）
   }
	 ES =  1;                   // 串口1中断打开
}


/*********************************END FILE********************************************/	

